/*
 * Copyright (c) 2006-2023, RT-Thread Development Team
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Change Logs:
 * Date           Author       Notes

 */

#include <rtthread.h>
#include <rtdevice.h>
#include "board.h"
#include "lpc_gpio.h"
#include "lpc_pinsel.h"
#ifdef BSP_USING_SPI

#if defined(BSP_USING_SPI1) || defined(BSP_USING_SPI2) || defined(BSP_USING_SPI3)

#include "drv_spi.h"
#include <string.h>

// #define DRV_DEBUG
#define LOG_TAG "drv.spi"
#include <rtdbg.h>

enum
{
#ifdef BSP_USING_SPI1
    SPI1_INDEX,
#endif
#ifdef BSP_USING_SPI2
    SPI2_INDEX,
#endif
#ifdef BSP_USING_SPI3
    SPI3_INDEX,
#endif

};

static struct lpc_spi_config spi_config[] =
    {
#ifdef BSP_USING_SPI1
        SPI1_BUS_CONFIG,
#endif

#ifdef BSP_USING_SPI2
        SPI2_BUS_CONFIG,
#endif

#ifdef BSP_USING_SPI3
        SPI3_BUS_CONFIG,
#endif
};

static struct lpc_spi spi_bus_obj[sizeof(spi_config) / sizeof(spi_config[0])] = {0};

static rt_err_t lpc_spi_init(struct lpc_spi *spi_drv, struct rt_spi_configuration *cfg)
{
    RT_ASSERT(spi_drv != RT_NULL);
    RT_ASSERT(cfg != RT_NULL);

    LPC_SSP_TypeDef *spi_handle = spi_drv->handle;

    SSP_CFG_Type n_spi_cfg;
    if (cfg->mode & RT_SPI_SLAVE)
    {
        n_spi_cfg.Mode = SSP_SLAVE_MODE;
    }
    else
    {
        n_spi_cfg.Mode = SSP_MASTER_MODE;
    }

    //    if (cfg->mode & RT_SPI_3WIRE)
    //    {
    //        n_spi_cfg.Init.Direction = SPI_DIRECTION_1LINE;
    //    }
    //    else
    //    {
    //        n_spi_cfg.Init.Direction = SPI_DIRECTION_2LINES;
    //    }

    if (cfg->data_width == 8)
    {
        n_spi_cfg.Databit = SSP_DATABIT_8;
    }
    else if (cfg->data_width == 16)
    {
        n_spi_cfg.Databit = SSP_DATABIT_16;
    }
    else
    {
        return -RT_EIO;
    }

    if (cfg->mode & RT_SPI_CPHA)
    {
        n_spi_cfg.CPHA = SSP_CPHA_SECOND;
    }
    else
    {
        n_spi_cfg.CPHA = SSP_CPHA_FIRST;
    }

    if (cfg->mode & RT_SPI_CPOL)
    {
        n_spi_cfg.CPOL = SSP_CPOL_HI;
    }
    else
    {
        n_spi_cfg.CPOL = SSP_CPOL_LO;
    }

    n_spi_cfg.Init.NSS = SPI_NSS_SOFT;
    n_spi_cfg.ClockRate = cfg->max_hz;

    if (cfg->mode & RT_SPI_MSB)
    {
        n_spi_cfg.Init.FirstBit = SPI_FIRSTBIT_MSB;
    }
    else
    {
        n_spi_cfg.Init.FirstBit = SPI_FIRSTBIT_LSB;
    }
    switch (spi_drv->Instance)
    {
    case LPC_SSP0:
        CLKPWR_ConfigPPWR(CLKPWR_PCONP_PCSSP0, ENABLE);
        break;
    case LPC_SSP1:
        CLKPWR_ConfigPPWR(CLKPWR_PCONP_PCSSP1, ENABLE);
        break;
    case LPC_SSP2:
        CLKPWR_ConfigPPWR(CLKPWR_PCONP_PCSSP2, ENABLE);
        break;
    default:
        break;
    }

    PINSEL_ConfigPin(PIN_PORT(spi_drv->clk.port), PIN_NO(spi_drv->clk.pin), spi_drv->clk.nFunc); // 0: Select GPIO (Default)
    // PINSEL_ConfigPin(PIN_PORT(spi_drv->ssel.port), PIN_NO(spi_drv->ssel.pin), spi_drv->ssel.nFunc); // 0: Select GPIO (Default)
    PINSEL_ConfigPin(PIN_PORT(spi_drv->miso.port), PIN_NO(spi_drv->miso.pin), spi_drv->miso.nFunc); // 0: Select GPIO (Default)
    PINSEL_ConfigPin(PIN_PORT(spi_drv->mosi.port), PIN_NO(spi_drv->mosi.pin), spi_drv->mosi.nFunc); // 0: Select GPIO (Default)
    SSP_Cmd(spi_handle, ENABLE);
    SSP_Init(spi_handle, &n_spi_cfg);
    if (HAL_SPI_Init(spi_handle) != HAL_OK)
    {
        return -RT_EIO;
    }

    /* DMA configuration */
    if (spi_drv->spi_dma_flag & SPI_USING_RX_DMA_FLAG)
    {
    }

    if (spi_drv->spi_dma_flag & SPI_USING_TX_DMA_FLAG)
    {
    }

    if (spi_drv->spi_dma_flag & SPI_USING_TX_DMA_FLAG || spi_drv->spi_dma_flag & SPI_USING_RX_DMA_FLAG)
    {
    }

    LOG_D("%s init done", spi_drv->config->bus_name);
    return RT_EOK;
}

static rt_ssize_t spixfer(struct rt_spi_device *device, struct rt_spi_message *message)
{
#define DMA_TRANS_MIN_LEN 10 /* only buffer length >= DMA_TRANS_MIN_LEN will use DMA mode */

    rt_size_t message_length, already_send_length;
    rt_uint16_t send_length;
    rt_uint8_t *recv_buf;
    const rt_uint8_t *send_buf;

    RT_ASSERT(device != RT_NULL);
    RT_ASSERT(device->bus != RT_NULL);
    RT_ASSERT(message != RT_NULL);

    struct lpc_spi *spi_drv = rt_container_of(device->bus, struct lpc_spi, spi_bus);
    LPC_SSP_TypeDef *spi_handle = spi_drv->handle;

    if (message->cs_take && !(device->config.mode & RT_SPI_NO_CS) && (device->cs_pin != PIN_NONE))
    {
        if (device->config.mode & RT_SPI_CS_HIGH)
            rt_pin_write(device->cs_pin, PIN_HIGH);
        else
            rt_pin_write(device->cs_pin, PIN_LOW);
    }

    LOG_D("%s transfer prepare and start", spi_drv->config->bus_name);
    LOG_D("%s sendbuf: %X, recvbuf: %X, length: %d",
          spi_drv->config->bus_name,
          (uint32_t)message->send_buf,
          (uint32_t)message->recv_buf, message->length);

    message_length = message->length;
    recv_buf = message->recv_buf;
    send_buf = message->send_buf;
    while (message_length)
    {
        /* the HAL library use uint16 to save the data length */
        if (message_length > 65535)
        {
            send_length = 65535;
            message_length = message_length - 65535;
        }
        else
        {
            send_length = message_length;
            message_length = 0;
        }

        /* calculate the start address */
        already_send_length = message->length - send_length - message_length;
        /* avoid null pointer problems */
        if (message->send_buf)
        {
            send_buf = (rt_uint8_t *)message->send_buf + already_send_length;
        }
        if (message->recv_buf)
        {
            recv_buf = (rt_uint8_t *)message->recv_buf + already_send_length;
        }

        rt_uint32_t *dma_aligned_buffer = RT_NULL;
        rt_uint32_t *p_txrx_buffer = RT_NULL;

        if ((spi_drv->spi_dma_flag & SPI_USING_TX_DMA_FLAG) && (send_length >= DMA_TRANS_MIN_LEN))
        {

            if (RT_IS_ALIGN((rt_uint32_t)send_buf, 4)) /* aligned with 4 bytes? */
            {
                p_txrx_buffer = (rt_uint32_t *)send_buf; /* send_buf aligns with 4 bytes, no more operations */
            }
            else
            {
                /* send_buf doesn't align with 4 bytes, so creat a cache buffer with 4 bytes aligned */
                dma_aligned_buffer = (rt_uint32_t *)rt_malloc(send_length); /* aligned with RT_ALIGN_SIZE (8 bytes by default) */
                rt_memcpy(dma_aligned_buffer, send_buf, send_length);
                p_txrx_buffer = dma_aligned_buffer;
            }
        }

        /* start once data exchange in DMA mode */
        if (message->send_buf && message->recv_buf)
        {

            if ((spi_drv->spi_dma_flag & SPI_USING_TX_DMA_FLAG) && (spi_drv->spi_dma_flag & SPI_USING_RX_DMA_FLAG) && (send_length >= DMA_TRANS_MIN_LEN))
            {
                SSP_DATA_SETUP_Type dataCfg = {.tx_data = p_txrx_buffer, .rx_data = p_txrx_buffer, .length = send_length};
                SSP_ReadWrite(spi_handle, &dataCfg, SSP_TRANSFER_POLLING);
                // state = HAL_SPI_TransmitReceive_DMA(spi_handle, (uint8_t *)p_txrx_buffer, (uint8_t *)p_txrx_buffer, send_length);
            }
            else if ((spi_drv->spi_dma_flag & SPI_USING_TX_DMA_FLAG) && (send_length >= DMA_TRANS_MIN_LEN))
            {
                SSP_DATA_SETUP_Type dataCfg = {.tx_data = p_txrx_buffer, .rx_data = p_txrx_buffer, .length = send_length};
                SSP_ReadWrite(spi_handle, &dataCfg, SSP_TRANSFER_POLLING);
                /* same as Tx ONLY. It will not receive SPI data any more. */
                // state = HAL_SPI_Transmit_DMA(spi_handle, (uint8_t *)p_txrx_buffer, send_length);
            }
            else if ((spi_drv->spi_dma_flag & SPI_USING_RX_DMA_FLAG) && (send_length >= DMA_TRANS_MIN_LEN))
            {
                state = HAL_ERROR;
                LOG_E("It shoule be enabled both BSP_SPIx_TX_USING_DMA and BSP_SPIx_TX_USING_DMA flag, if wants to use SPI DMA Rx singly.");
                break;
            }
            else
            {
                SSP_DATA_SETUP_Type dataCfg = {.tx_data = send_buf, .rx_data = recv_buf, .length = send_length};
                state = HAL_SPI_TransmitReceive(spi_handle, (uint8_t *)send_buf, (uint8_t *)recv_buf, send_length, 1000);
            }
        }
        else if (message->send_buf)
        {
            if ((spi_drv->spi_dma_flag & SPI_USING_TX_DMA_FLAG) && (send_length >= DMA_TRANS_MIN_LEN))
            {
                SSP_DATA_SETUP_Type dataCfg = {.tx_data = p_txrx_buffer, .rx_data = p_txrx_buffer, .length = send_length};
                SSP_ReadWrite(spi_handle, &dataCfg, SSP_TRANSFER_POLLING);
                // state = HAL_SPI_Transmit_DMA(spi_handle, (uint8_t *)p_txrx_buffer, send_length);
            }
            else
            {
                SSP_DATA_SETUP_Type dataCfg = {.tx_data = send_buf, .rx_data = send_buf, .length = send_length};
                SSP_ReadWrite(spi_handle, &dataCfg, SSP_TRANSFER_POLLING);
                state = HAL_SPI_Transmit(spi_handle, (uint8_t *)send_buf, send_length, 1000);
            }

            if (message->cs_release && (device->config.mode & RT_SPI_3WIRE))
            {
                /* release the CS by disable SPI when using 3 wires SPI */
                __HAL_SPI_DISABLE(spi_handle);
            }
        }
        else if (message->recv_buf)
        {
            rt_memset((uint8_t *)recv_buf, 0xff, send_length);
            if ((spi_drv->spi_dma_flag & SPI_USING_RX_DMA_FLAG) && (send_length >= DMA_TRANS_MIN_LEN))
            {
                SSP_DATA_SETUP_Type dataCfg = {.tx_data = p_txrx_buffer, .rx_data = p_txrx_buffer, .length = send_length};
                SSP_ReadWrite(spi_handle, &dataCfg, SSP_TRANSFER_POLLING);

                // state = HAL_SPI_Receive_DMA(spi_handle, (uint8_t *)p_txrx_buffer, send_length);
            }
            else
            {
                /* clear the old error flag */
                SSP_DATA_SETUP_Type dataCfg = {.tx_data = recv_buf, .rx_data = recv_buf, .length = send_length};
                SSP_ReadWrite(spi_handle, &dataCfg, SSP_TRANSFER_POLLING);
                // state = HAL_SPI_Receive(spi_handle, (uint8_t *)recv_buf, send_length, 1000);
            }
        }
        else
        {
            state = HAL_ERROR;
            LOG_E("message->send_buf and message->recv_buf are both NULL!");
        }

        if (state != HAL_OK)
        {
            LOG_E("SPI transfer error: %d", state);
            message->length = 0;
            n_spi_cfg.State = HAL_SPI_STATE_READY;
            break;
        }
        else
        {
            LOG_D("%s transfer done", spi_drv->config->bus_name);
        }

        /* For simplicity reasons, this example is just waiting till the end of the
           transfer, but application may perform other tasks while transfer operation
           is ongoing. */
        if ((spi_drv->spi_dma_flag & (SPI_USING_TX_DMA_FLAG | SPI_USING_RX_DMA_FLAG)) && (send_length >= DMA_TRANS_MIN_LEN))
        {
            /* blocking the thread,and the other tasks can run */
            if (rt_completion_wait(&spi_drv->cpt, 1000) != RT_EOK)
            {
                state = HAL_ERROR;
                LOG_E("wait for DMA interrupt overtime!");
                break;
            }
        }
        else
        {
            // while (HAL_SPI_GetState(spi_handle) != HAL_SPI_STATE_READY)
            //     ;
        }

        if (dma_aligned_buffer != RT_NULL) /* re-aligned, so need to copy the data to recv_buf */
        {
            if (recv_buf != RT_NULL)
            {
                rt_memcpy(recv_buf, p_txrx_buffer, send_length);
            }

            rt_free(dma_aligned_buffer);
        }
    }

    if (message->cs_release && !(device->config.mode & RT_SPI_NO_CS) && (device->cs_pin != PIN_NONE))
    {
        if (device->config.mode & RT_SPI_CS_HIGH)
            rt_pin_write(device->cs_pin, PIN_LOW);
        else
            rt_pin_write(device->cs_pin, PIN_HIGH);
    }

    if (state != HAL_OK)
    {
        return -RT_ERROR;
    }
    return message->length;
}

static rt_err_t spi_configure(struct rt_spi_device *device,
                              struct rt_spi_configuration *configuration)
{
    RT_ASSERT(device != RT_NULL);
    RT_ASSERT(configuration != RT_NULL);

    struct lpc_spi *spi_drv = rt_container_of(device->bus, struct lpc_spi, spi_bus);
    spi_drv->cfg = configuration;

    return lpc_spi_init(spi_drv, configuration);
}

static const struct rt_spi_ops stm_spi_ops =
    {
        .configure = spi_configure,
        .xfer = spixfer,
};

static int rt_hw_spi_bus_init(void)
{
    rt_err_t result;

    for (rt_size_t i = 0; i < sizeof(spi_config) / sizeof(spi_config[0]); i++)
    {
        spi_bus_obj[i].config = &spi_config[i];
        spi_bus_obj[i].spi_bus.parent.user_data = &spi_config[i];
        spi_bus_obj[i].handle.Instance = spi_config[i].Instance;

        /* initialize completion object */
        rt_completion_init(&spi_bus_obj[i].cpt);

        result = rt_spi_bus_register(&spi_bus_obj[i].spi_bus, spi_config[i].bus_name, &stm_spi_ops);
        RT_ASSERT(result == RT_EOK);

        LOG_D("%s bus init done", spi_config[i].bus_name);
    }

    return result;
}

/**
 * Attach the spi device to SPI bus, this function must be used after initialization.
 */
rt_err_t rt_hw_spi_device_attach(const char *bus_name, const char *device_name, rt_base_t cs_pin)
{
    RT_ASSERT(bus_name != RT_NULL);
    RT_ASSERT(device_name != RT_NULL);

    rt_err_t result;
    struct rt_spi_device *spi_device;

    /* attach the device to spi bus*/
    spi_device = (struct rt_spi_device *)rt_malloc(sizeof(struct rt_spi_device));
    RT_ASSERT(spi_device != RT_NULL);

    result = rt_spi_bus_attach_device_cspin(spi_device, device_name, bus_name, cs_pin, RT_NULL);
    if (result != RT_EOK)
    {
        LOG_E("%s attach to %s faild, %d\n", device_name, bus_name, result);
    }

    RT_ASSERT(result == RT_EOK);

    LOG_D("%s attach to %s done", device_name, bus_name);

    return result;
}

void SSP0_IRQHandler(void)
{
    /* enter interrupt */
    rt_interrupt_enter();

    /* leave interrupt */
    rt_interrupt_leave();
}
void SSP1_IRQHandler(void)
{
    /* enter interrupt */
    rt_interrupt_enter();

    /* leave interrupt */
    rt_interrupt_leave();
}
void SSP1_IRQHandler(void)
{
    /* enter interrupt */
    rt_interrupt_enter();

    /* leave interrupt */
    rt_interrupt_leave();
}

// void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)
// {
//     struct lpc_spi *spi_drv = rt_container_of(hspi, struct lpc_spi, handle);
//     rt_completion_done(&spi_drv->cpt);
// }

// void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi)
// {
//     struct lpc_spi *spi_drv = rt_container_of(hspi, struct lpc_spi, handle);
//     rt_completion_done(&spi_drv->cpt);
// }

// void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
// {
//     struct lpc_spi *spi_drv = rt_container_of(hspi, struct lpc_spi, handle);
//     rt_completion_done(&spi_drv->cpt);
// }
int rt_hw_spi_init(void)
{
    lpc_get_dma_info();
    return rt_hw_spi_bus_init();
}
INIT_BOARD_EXPORT(rt_hw_spi_init);

#endif /* BSP_USING_SPI1 || BSP_USING_SPI2 || BSP_USING_SPI3 || BSP_USING_SPI4 || BSP_USING_SPI5 */
#endif /* BSP_USING_SPI */
