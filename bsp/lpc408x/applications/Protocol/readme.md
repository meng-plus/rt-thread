# 通用协议栈主/从机收发处理框架

版本：V0.1

日期：2023年10月19日

高度可配置性，允许根据不同协议需求快速配置参数

支持多种通信接口，如 UART、SPI、I2C 等，提供完善的 API 接口，方便用户进行二次开发

采用模块化设计，便于维护和升级

支持多任务处理，提高系统性能

代码冗余少，易于理解和移植

### 技术选型

编程语言：C99

处理器架构：Cortex-M，32 位机适配

操作系统：不限制

通信接口：UART、SPI、I2C 等

校验方法：CRC、奇偶校验等

## :eye:简要介绍

协议种类很多但是他们都有一个共性的功能，接收、断帧、校验、帧处理、回应、超时等固有的需求，需求的统一就有可能将其封装降低后续的工作量。依托于我当前项目需求，将开发第一版的协议栈框架，现将规划整理如下：

1. 主机、从机框架开发
2. 解耦合，降低对环境依赖
3. 内部不使用内存申请，提高兼容性
4. fifo报文队列
5. 协议层
6. 应用层

### 首先复习下OSI模型

**OSI模型（七层模型）**：

1. 物理层（Physical Layer）：负责传输数据的物理介质，如电缆、光纤和无线信号。它处理比特流的物理传输。
2. 数据链路层（Data Link Layer）：负责在直接相连的设备之间进行数据帧的传输，包括数据的发送、接收和物理地址的解析。
3. 网络层（Network Layer）：处理数据包的路由、寻址和转发，以确保数据能够从源到目的地传递。
4. 传输层（Transport Layer）：提供端到端的数据传输服务，包括可靠的数据传输和错误检测、纠正，常见协议如TCP和UDP。
5. 会话层（Session Layer）：负责建立、维护和结束通信会话，同时处理会话中的同步和错误恢复。
6. 表示层（Presentation Layer）：处理数据的编码、压缩和加密，以确保数据在不同系统之间的互操作性。
7. 应用层（Application Layer）：提供应用程序之间的通信接口，包括各种应用层协议，如HTTP、FTP、SMTP等。

**TCP/IP模型（四层模型）**：

1. 网络接口层（Network Interface Layer）：类似于OSI模型中的物理层和数据链路层，处理物理介质和数据帧的传输。
2. 网际层（Internet Layer）：类似于OSI模型中的网络层，处理数据包的路由和转发，包括IP协议。
3. 传输层（Transport Layer）：与OSI模型中的传输层相对应，提供端到端的数据传输服务，包括TCP和UDP协议。
4. 应用层（Application Layer）：与OSI模型中的会话、表示和应用层相对应，提供各种应用层协议和服务。

## 传输层（Transport Layer）

传输层是协议栈的一个核心组成部分，负责在不同设备之间建立可靠的通信通道。具体功能包括：

1. **数据打包和解包**：传输层将数据分割成较小的数据包以进行传输，并在接收端重新组装这些数据包。这有助于降低数据传输的复杂性和提高效率。

2. **数据传输控制**：传输层负责确保数据的可靠传输。它可以包括重传机制、错误检测和纠正等功能，以应对通信中可能出现的问题。

3. **数据流控制**：传输层可以管理数据的流动速率，以防止发送方发送数据过快，导致接收方无法处理。这有助于平衡数据的发送和接收。

## 会话层（Session Layer）

### 主机

在协议栈的主机部分，我们专注于处理多设备、多命令和检测设备掉线等问题。具体功能规划如下：

1. **调用协议层**：主机部分将与协议层协同工作，以确保数据正确封装和解封装。

2. **消息队列的发送和接收**：主机将维护用于发送和接收消息的队列，以确保数据的有序传输。

3. **设备管理**：主机负责设备的注册和管理，包括检测设备是否在线，处理设备掉线等问题。

4. **多命令支持**：主机应具备处理多种不同命令的能力，以满足多样化的通信需求。

### 从机

从机的主要职责是解析命令，并执行相应的处理函数。功能规划如下：

1. **调用协议层**：从机部分需要与协议层协同工作，以确保命令的正确解析和生成响应。

2. **命令与处理函数的映射**：从机将维护一个命令到处理函数的映射表，以根据接收到的命令选择适当的处理函数。

3. **消息队列的发送和接收**：从机也需要维护消息队列，以进行消息的发送和接收。

4. **扩展性**：从机应具备良好的扩展性，以支持不断增加的命令和功能，同时保持高效性和稳定性。

## 应用层（Application Layer）

应用层是协议栈的最顶层部分，负责处理具体的应用逻辑。针对不同的应用需求，应用层将根据我们的协议框架的特性进行定制化开发。这包括：

1. **应用协议**：应用层将定义特定于应用的通信协议，以实现应用之间的数据交换。这可能包括传感器数据的采集、远程控制命令的执行等。

2. **业务逻辑**：应用层将实现应用的具体业务逻辑，如数据处理、决策制定、用户界面等。

3. **定制化功能**：根据应用的需求，应用层可以定制各种功能，例如安全性、加密、数据压缩等。

4. **应用示例**：我们将提供一些示例应用代码，以帮助开发者更容易地构建自己的通信应用。这些示例将涵盖各种常见的应用场景，以便快速上手。

应用层的特性和功能将根据具体的应用需求进行个性化开发，以确保协议栈框架能够满足不同应用领域的要求。

## :wrench: 如何使用通用协议栈框架

使用通用协议栈框架可以帮助您快速构建各种嵌入式通信应用。以下是一些基本的步骤和示例，以帮助您入门和开始使用这个框架。

### 步骤 1: 集成协议栈框架

首先，您需要将协议栈框架集成到您的嵌入式项目中。这包括将框架的源代码文件添加到您的项目中，并在您的项目中包含必要的头文件。具体的集成步骤可能因您的开发环境和硬件平台而异，但通常包括以下几个方面：

- 复制协议栈框架的源代码文件到您的项目目录。
- 在您的项目中包含协议栈框架的头文件。
- 配置框架的编译选项以适应您的硬件平台。
- 构建并编译您的项目，确保协议栈框架成功集成。

### 步骤 2: 配置通信协议

根据您的应用需求，配置通信协议。这包括选择合适的物理层协议（例如UART、SPI、I2C等）以及定义应用层协议消息格式。根据您的应用需求，您还可以添加安全性和加密特性。

示例代码：

```c
// 配置UART通信协议
UART_Config uartConfig;
uartConfig.baudRate = 9600;
uartConfig.dataBits = 8;
uartConfig.parity = PARITY_NONE;
uartConfig.stopBits = 1;
Protocol_SetupUART(&uartConfig);

// 定义应用层协议消息格式
typedef struct {
    uint8_t command;
    uint16_t data;
} MyAppMessage;
```

### 步骤 3: 主机和从机配置

根据您的应用场景，配置主机和从机的功能和行为。主机和从机在通信中扮演不同的角色，需要分别配置。例如，主机可能需要配置多设备支持，而从机需要定义命令和处理函数。

示例代码：

主机配置：

```c
// 配置主机
HostConfig hostConfig;
hostConfig.deviceCount = 10;  // 支持最多10个设备
hostConfig.timeout = 1000;    // 超时时间1秒
Protocol_SetupHost(&hostConfig);
```

从机配置：

```c
// 配置从机
SlaveConfig slaveConfig;
slaveConfig.commandMap[CMD_READ_SENSOR] = ReadSensorHandler;
slaveConfig.commandMap[CMD_CONTROL_DEVICE] = ControlDeviceHandler;
Protocol_SetupSlave(&slaveConfig);
```

### 步骤 4: 数据传输和处理

开始进行数据传输和处理。主机和从机之间可以开始相互通信，并进行数据交换。您需要使用框架提供的API函数来发送和接收数据。

示例代码：

主机发送数据：

```c
MyAppMessage message;
message.command = CMD_READ_SENSOR;
message.data = 0;
Protocol_SendData(&message, sizeof(MyAppMessage), slaveAddress);
```

从机接收和处理数据：

```c
uint8_t rxBuffer[256];
size_t rxSize = Protocol_ReceiveData(rxBuffer, sizeof(rxBuffer));

if (rxSize > 0) {
    // 解析数据
    MyAppMessage* receivedMessage = (MyAppMessage*)rxBuffer;
    
    // 执行命令处理函数
    if (receivedMessage->command == CMD_READ_SENSOR) {
        ReadSensorHandler(receivedMessage);
    } else if (receivedMessage->command == CMD_CONTROL_DEVICE) {
        ControlDeviceHandler(receivedMessage);
    }
}
```

### 步骤 5: 应用层开发

最后，您可以根据您的应用需求在应用层开发特定的业务逻辑和功能。这包括数据处理、决策制定以及用户界面等方面。您可以使用示例代码和协议栈框架提供的功能来构建自己的应用层。

示例代码：

```c
void ReadSensorHandler(MyAppMessage* message) {
    // 读取传感器数据
    uint16_t sensorData = ReadSensor();
    
    // 将数据发送回主机
    MyAppMessage response;
    response.command = CMD_SENSOR_DATA;
    response.data = sensorData;
    
    Protocol_SendData(&response, sizeof(MyAppMessage), hostAddress);
}
```

通过遵循这些步骤，您可以开始使用通用协议栈框架构建自己的嵌入式通信应用。请注意，具体的代码和配置将根据您的应用需求和硬件平台而有所不同。

## :bookmark_tabs: 开发计划

- [ ] 完成主机、从机框架的开发，实现基本的数据收发功能
- [ ] 实现解耦合，降低对环境依赖，提高兼容性
- [ ] 完成内部不使用内存申请，提高兼容性
- [ ] 实现高度可配置性，支持多种通信接口
- [ ] 提供完善的 API 接口，方便用户进行二次开发
- [ ] 完成模块化设计，支持多任务处理
- [ ] 进行系统优化和测试，提高系统性能
- [ ] 完成代码审查和文档编写，准备发布

## :rocket: 预期成果

我们的目标是打造一个灵活、高性能、易于使用的通用协议栈框架，以满足各种嵌入式通信应用的需求。我们期待在未来几个月内发布第一个稳定版本，同时不断推出新功能和改进，以使这个框架成为开发者的首选工具。

如果您对我们的协议栈框架有任何建议、合作意向或其他需求，请随时与我们联系。我们欢迎各种形式的合作，以实现通信领域的共同目标。感谢您对我们项目的关注和支持！

## :page_with_curl: 开源协议

我们的通用协议栈框架将遵循一个自由和开放的开源协议，以鼓励广泛的使用和贡献。目前，我们计划采用[MIT开源许可证](https://opensource.org/licenses/MIT)。这意味着您可以自由地使用、修改和分发这个框架，只需遵守许可证的规定，包括保留版权声明和许可证信息。我们希望这个协议能够为开发者提供灵活性，使他们能够构建出色的通信应用。

## :heart: 捐赠说明

如果您认可我们的协议栈框架，并希望支持项目的持续发展，您可以考虑向我们捐赠。您的捐赠将用于项目的维护、改进和提供更多的资源，以确保框架的高质量和持续发展。我们非常感谢每一位支持者的慷慨捐赠。

我们计划建立一个捐赠渠道，以接受来自社区的捐赠。一旦渠道建立，我们将提供详细的捐赠信息，包括接受的捐赠形式和用途。

再次感谢您的支持和关注，您的捐赠将有助于推动通用协议栈框架的发展，使其更好地服务开发者社区。



## :bust_in_silhouette: 关于作者

通用协议栈框架的作者一群充满激情和经验丰富的嵌入式系统和通信领域的专业人士。我热衷于解决通信协议栈的复杂性，以帮助开发者更轻松地构建各种嵌入式通信应用。以下是关于我们的一些信息：

- **姓名**:meng-plus
- **背景**: 我拥有多年的嵌入式系统和通信领域的经验。我们曾在各种项目中工作，从嵌入式设备的低级硬件控制到高级通信协议的实现。
- **愿景**: 我的愿景是创建一个通用协议栈框架，使开发者能够更快速、更容易地构建各种通信应用，无论是在物联网、工业自动化还是其他领域。
- **联系方式**: 如果您有任何问题、建议或合作意向，欢迎随时联系我们。您可以通过[作者的电子邮件](mailto:chengmeng_2@outlook.com)与我取得联系。

感谢您的支持和信任，期待与全球的开发者社区一起推动通用协议栈框架的发展，使其成为通信领域的有力工具。
